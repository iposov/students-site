# Лекции

1. Лекция 1. [Коллекции в Java](lecture1-collections.md)
2. Лекция 2. [Ассоциативные массивы и абстрактные классы](lecture2-maps.md)
2. Лекция 3. [Интерфейсы и лямбда выражения](lecture3-interfaces-lambda.md)
2. Лекция 4. [Использование лямбда выражений, JavaFX](lecture4-lambdas-javafx.md)
2. Лекция 5. [JavaFX Сцена](lecture5-scene.md)

# Задачи для практических занятий

## Объектно-ориентированное программирование

### Класс "Время"

*Дедлайн*: 3 марта

*пакет*: `ru.spbu.arts.java.oop.time`

Вы должны создать класс `ExperimentsWithTime`, чтобы в нем проверять всё, что вы сделаете
с часами. Нужно проверить работу каждого пункта, который вы выполните.
Пожалуйста, в окончательной версии не ставьте комментарии на куски кода, которые
проверяют работу вашего класса, обычно так делают, чтобы старые проверки не мешали
новым. Так вот, не надо комментировать проверки.

1. Заведите класс `Time`, который хранит информацию о количестве часов
   и минут. Т.е. введите два поля.
1. Добавьте конструктор, в котором можно сразу указать количество часов и минут.
1. Сделайте метод `String show();`, который возвращает строку с часами и минутами
   через двоеточие. Например, он может вернуть `"09:10"`.
1. Сделайте методы isDay(), isMorning(), isEvening(), isNight(), которые
   возвращают верно ли, что сейчас, соответственно, день, утро, вечер, ночь. Придумайте
   сами, начиная с какого времени утро переходит в день и т.п.
1. Сделайте метод `String sayHello()`, который возвращает строку "Доброе утро",
   "Добрый день" и т.п. в зависимости от текущего времени.
1. Сделайте метод, который добавляет указанное количество минут:
   `c.add(20)`. Если было `"9:10"`, то должно получиться `"9:30"`. А если было
   `"9:50"`, должно получиться `"10:10"`. Еще пример. `"9:20"` плюс 120 минут
   должно быть `"11:20"`.

### ASCI-графика

*Дедлайн*: 3 марта

*пакет*: `ru.spbu.arts.java.oop.ascigraphics`

Класс Drawing (изображение) хранит изображение в виде массива символов `char[][]`. Например,
```
.........
.........
....x....
.........
```
1. Создайте конструктор, в котором указывается размер (сколько строк и столбцов) и символ, которым изначально все заполнить. Например,
   new Drawing(20, 30, '.')
1. Создайте метод `print()`, он печатает на экране изображение
1. Метод `setPoint(x, y, char)` рисует один символ в изображении. Методу нужно указать, где и какой символ поставить.
1. Методы `drawVerticalLine(...)`, `drawHorizontalLine(...)` рисуют вертикальную
   или горизонтальную линию от заданной точки до заданной. Определите сами параметры для методов, они должны определять расположение линии и символ, которым линию рисовать.
1. Метод `drawRectangle()` рисует прямоугольник по двум противоположным углам, стороны прямоугольника вертикальны и горизонтальны. Используйте методы, реализованные ранее.
1. Необязательно: Рисование произвольной линии (см. необязательную задачу за прошлый семестр)
1. Рисование круга (или окружности — необязательно). Пользователь указывает центр и радиус, программа должна пройтись по всем точкам поля и, если они лежат в круге, зарисовать их указанным символом.
1. Реализуйте метод `draw(x, y, Drawing d)` нарисовать одно изображение на другом. При вызове метода указывается, где и какое изображение рисовать.
1. (Необязательная задача). Сделайте Drawing неизменяемым: все функции рисования возвращают новый Drawing и не меняют текущий.
   Чтобы не портить старый класс, назовите новый ImmutableDrawing.
1. Используйте все реализованные вами ранее методы, чтобы нарисовать Джоконду.
   Ну или домик.

### Рациональные числа

*Дедлайн*: 10 марта

*пакет*: `ru.spbu.arts.java.oop.rational`

Сделаем класс Rational, это рациональные числа, для которых хранится их числитель
и знаменатель. С рациональными числами можно совершать арифметические операции.

1. Создайте класс и добавьте поля n и d (numerator, denominator - числитель,
   знаменатель). Убедитесь, что поля приватные.
1. Класс должен иметь конструкторы вида `Rational(3, 2)` и `Rational(3)`.
1. Добавьте метод `public String toString()`, который возвращает естественное
   представление числа в виде строки, например, `5/7`. Если знаменатель равен 1,
   его не нужно писать. Если числитель ноль, то "0", а не "0/2" и т.п.
1. Добавьте метод double toDouble(), который возвращает значение в виде double.
1. Добавьте сокращение дроби в конструктор: поделить числитель и знаменатель
   на НОД, убедиться, что знаменатель положительный.
1. Арифметические функции. add, sub, mul, div:

        Rational r1 = r2.add(r3); // создает новое число
        r2.addInPlace(r3); // добавляет к r2 и изменяет его

   Протестируйте! Проверьте, например, что \\(\\frac16 + \\frac13 = \\frac12\\),
   и проверьте другие аналогичные равенства для других арифметических операций.
1. Создайте функцию ___не в Rational___, которая по n считает
   \\(1 + \\frac12 + \\frac13 + \\frac14 + \\frac15 + ... + \\frac1n\\)
   Проверьте, что f(1) = 1, f(2) = 1.5, f(3) = 1.833333333333333
1. Чему равно f(20)? Почему оно равно тому, чему равно? Как исправить?
1. Добавьте get- методы для числителя и знаменателя. Чтобы Rational стал совсем неизменяемым, закомментируйте методы `*InPlace()`.
1. Создайте статические константы ONE и ZERO типа Rational, хранящие элементы 0, 1 в виде рациональных чисел.
1. Сделайте статическим метод поиска НОД (или сокращения)
1. Создайте статические версии арифметических операций: `static Rational add(Rational r1, Rational r2)` и т.п. Эти операции создают новое число, вы можете переиспользовать старые арифметические операции.

## Коллекции

*Дедлайн*: 17 марта

1. Создайте список из чисел от 1 до $n$, где $n$ в качестве аргумента. Заголовок функции `List<Integer> count(int n)`. Внутри создайте `ArrayList`. 
2. Сделайте функцию, которая распечатывает длину списка и его значения построчно. Используйте цикл `for each`
    ```
    List<String> list1 = List.of("abc", "xyz", "ooo");
    
    // на экране появится
    //   Элементов в списке: 3
    //   abc
    //   xyz
    //   ooo
    printList(list1);
    ```
1. Аналогично предыдущему, но вместе с элементами печатаются их индексы. Здесь можете использовать любой цикл.
    ```
    List<String> list2 = List.of("abc", "xyz", "ooo");
    
    // на экране появится
    //   Элементов в списке: 3
    //   1: abc
    //   2: xyz
    //   3: ooo
    printListWithIndices(list1);
    ```   
1. Сделайте функцию, которая получает два списка и возвращает один, состоящий из двух заданных. Склеивает списки.
    ```
    List<String> list3 = List.of("aaa", "bbb", "ccc");
    List<String> list4 = List.of("xxx", "yyy", "zzz");
    List<String> list3plusList4 = concatenateLists(list3, list4);
    System.out.println(list3plusList4); //aaa bbb ccc xxx yyy zzz
    // можно не проверять, что исходные списки не изменились, потому что List.of()
    // создает неизменяемый список. Но можно и проверить:
    System.out.println(list3); //aaa bbb ccc
    System.out.println(list4); //xxx yyy zzz
    ```
1. Дан список, верните новый список, в котором все элементы идут в обратном порядке.
   Сделайте две версии задачи: чистую функцию и функцию, которая меняет заданный список.
    ```
    //созадем изменяемый список list5.
    List<String> list5 = new ArrayList<>(List.of("first", "middle", "last"));
    //сначала чистая функция
    List<String> list5rev = reverseList(list5);
    //проверяем, что list5rev перевернутый, а list5 остался без изменений.
    System.out.println("list5rev = " + list5rev + ", but list5 = " + list5);
   
    //теперь функция, которая меняет сам список
    reverseListInPlace(list5);
    //проверяем, что список действительно изменился
    System.out.println("list5 = " + list5);
    ```
1. Сделайте по две версии следующих трех функций: чистую функцию и функцию, которая меняет заданный список.
   * Дан `List<Integer>`, удалите в нем все элементы с четным индексом.
   * Дан `List<Integer>`, удалить в нем все элементы, которые являются четными числами
   * Дан `List<Integer>`, удалить в нем все элементы, которые являются четными числами

    ```
    List<Integer> ints = List.of(11, 22, 33, 55, 66, 88, 100, 3, 4);
    
    System.out.println("ints = " + ints);
    //функция должна удалить элементы с четными индексами, т.е. оставить только каждое второе число
    System.out.println("ints no even indices = " + filterEvenIndices(ints)); //["22", "55", "88", "3"]
    //функция должна удалить четные числа
    System.out.println("ints without even = " + filterEven(ints)); //["11", "33", "55", "3"]
    
    // В этой части мы проделаем то же самое, но с функциями, которые изменяют переданные списки.
    // слово mutable означает "изменяемый", потому что в этой части мы будем использовать списки,
    // которые можно изменять.
    System.out.println(" ============= mutable lists =================== ");
    
    List<Integer> mutableInts = new ArrayList<>(ints);
    mutableFilterEvenIndices(mutableInts);
    System.out.println("ints no even indices = " + mutableInts); //[22, 55, 88, 3]
    
    mutableInts = new ArrayList<>(ints);
    mutableFilterEven(mutableInts);
    System.out.println("ints without even = " + mutableInts); //[11, 33, 55, 3]
    ```

1. Взять текстовый файл, желательно большой на русском. Прочитать из него все слова, каждое слово привести к нижнему регистру и
   сохранить в множестве `HashSet`. Вывести все слова.
   * Повторите аналогичные действия для `TreeSet`, `LinkedHashSet`. Т.е. Ваша программа должна читать текстовый файл три раза.
     Убедитесь, что вы не дублируете код, и не скопировали программу три раза для каждого из видов множества. Для этого
     создайте три разных множества и передавайте их в функцию следующим образом:

    ```
    Set<String> hashSet = new HashSet<>();
    Set<String> linkedHashSet = new LinkedHashSet<>();
    Set<String> treeSet = new TreeSet<>();
    
    doReadWordsInFile("a.txt", hashSet);
    doReadWordsInFile("a.txt", linkedHashSet);
    doReadWordsInFile("a.txt", treeSet);
    ```

