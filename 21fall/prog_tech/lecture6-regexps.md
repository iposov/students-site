# Регулярные выражения

Позволяют обрабатывать строки, находить в них нужные части, выделять их или заменять на другие строки.

Вообще, регулярное выражение описывает **множество строк**.

Примеры:
1. `abc`: `"abc"`
2. `xyz 123`: `"xyz 123"`
3. `abc|xyz|pqr`: `"abc"`, `"xyz"`, `"pqr"`

Проверить, что строка принадлежит множеству, описываемому регулярным выражением, можно с помощью функции `matches`: 
```
СТРОКА.matches(РЕГУЛЯРНОЕ ВЫРАЖЕНИЕ)
```
Это истина, если строка принадлежит множеству.

Продолжаем примеры:
4. `a(x|y|z)b`: `"axb"`, `"ayb"`, `"azb"`
5. `(a|b|c)(a|b|c)(a|b|c)`: `"aaa"`, `"bcc"`, `"abc"`,...
6. `(a|b|c|)(a|b|c|xy)(a|b|c)`: `"aaa"`, `"xyc"`, `"bb"`, ...
7. `прыгающ(ий|его|ему|им|ем|ими)`: `"прыгающими"`, `"прыгающий"`, ...
8. `a*`: `""`, `"a"`, `"aa"`, `"aaa"`, ...
9. `(ab)*`: `""`, `"ab"`, `"abab"`, `"ababab"`, ...
10. `ab*`: `"a"`, `"ab"`, `"abb"`, `"abbb"`, ...
11. `(a|bc*)z`: `"az"`, `"bz"`, `"bcz"`, `"bccz"`, `"bcccz"`
12. `(a|b)*`: `""`, `"a"`, `"b"`, `"aa"`, `"bb"`, `"ababaa"`
13. `\d`: эквивалентно `0|1|2|3|4|5|6|7|8|9`
14. `\d\d:\d\d` - время, но может быть `"33:12"`
15. `(0|1)\d:(0|1|2|3|4|5)\d` - время без 20, 21, 22, 23 часов
16. `((0|1)\d|20|21|22|23):(0|1|2|3|4|5)\d`

Посмотрим сайт [regexr.com](regexr.com)

Пример 16 и 15 — примеры того, как лучше не делать. Регулярные выражения должны описывать «синтаксис» строки, а не «семантику». Если нужно искать время в тексте, лучше найти строки из примера 13, т.е. две цифры, двоеточие, две цифры, а потом отдельно проверить, что они образуют время, т.е. кол-во часов до 24, количество минут до 60. Иначе регулярные выражения становятся очень сложными.

 Смотрим возможности регулярных выражений дальше.
 
17. В квадратных скобках можно писать выбор одного символа из нескольких:
  `[0123456789]` — эквивалентно `(0|1|2|3|4|5|6|7|8|9)` или `\d`.
18. `[ABC][abc]` — это слова `"Aa"`, `"Ab"`, `"Bb"`
19. `[ABC][abc]*` — это слова `"Aabcccbacbacba"`, `"A"`, `"Bbbba"`
20. `[A-Z][a-z]*` — это слова, начинающиеся с заглавной буквы. Допустимы буквы из диапазона от 'a' до 'z'.
21. `[A-Za-z.,!\d]` — любой символ латинская буква, точка, запятая, восклицательный знак или цифра.
22. `[A-Za-z]*` — это последовательность из латинских букв.
23. `cats?` или `cat(s)?` — буква s либо берется, либо не берется: `"cat"`, `"cats"`.
24. `ab+` — повторяется хотя бы 1 раз: `"ab"`, `"abb"`, `"abbb"`, ...
25. `ab{2,4}` —— "abb"`, `"abbb"`, `"abbbb"`.
26. Точка — любой символ: `.*` — под это подходит вообще любая строка.
27. `abc.xyz` — `"abc#xyz"`, `"abc xyz"`, `"abc1xyz"`, `"abcRxyz"`, `"abc,xyz"`, `"abcaxyz"`.  
Все возможности регулярных выражений: [Класс Pattern, Java Docs 17](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html).

## Как же пользоваться регулярными выражениями в Java
### Как записать регулярное выражение в виде строки

Пусть у нас есть регулярное выражение `\d{4}`, т.е.
строки, состоящие из 4ёх цифр. Если записать его в Java напрямую, будет странно: `"\d{4}"`. Java выдаст ошибку, потому что она не знает, что такое `\d`. `\n` — это перевод строки, а `\d` ??

Но мы знаем, что если нам нужна строка `\d{4}`, мы должны экранировать некоторые символы, в данном случае, `\`. Поэтому в Java это регулярное выражение выглядит `\\d{4}`.

В Python есть r-строки, там можно писать `r"\d{4}". Вместо "\\d{4}".

Еще пример.

Выражение для путей на диске`[A-Z]:\\[A-Za-z]+\\[A-Za-z]+\.txt`. (например, `"C:\Windows\a.txt"`). Внутри регулярного выражения приходится экранировать обратные слэши, потому что иначе обратный слэш будет не обратным слэшом, а символом экранирования.

Чтобы записать это в виде Java String, нужно снова экранировать все обратные слэши: `"[A-Z]:\\\\[A-Za-z]+\\\\[A-Za-z]+\\.txt"`.

### Как проверить, что строка подходит под регулярное выражение.

Первый способ, метод `matches`, см. выше.

Второй способ, мы можем создать переменную типа `Pattern`, в значениях этого типа хранятся регулярные выражения.

```
Pattern p1 = Pattern.compile("выражение");
Pattern p2 = Pattern.compile("выражение", флаги);
```

Флаги управляют тем, как будет работать регулярное выражение, все возможные флаги перечислены далее:
CASE_INSENSITIVE (игнорирование регистра), MULTILINE (см. ниже), DOTALL (точка соответствует любому символу, иначе точка означает всё кроме переводов строки), UNICODE_CASE (лучше указывать вместе с case_insensitive), CANON_EQ, UNIX_LINES, LITERAL, UNICODE_CHARACTER_CLASS and COMMENTS.

Про Multiline: `^` означает начало строки, `$` означает конец строки. А без режима Multiline они означают начало ввода и конец ввода соответственно.

Чтобы создать регулярное выражение с нужным набором флагов, пишем, соединяя флаги через '+'.

```
Pattern p2 = Pattern.compile("(\d\d):(\d\d)", Pattern.MULTILINE + Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE);
```

После создания регулярного выражения, его можно использовать для сопоставления с разными строками. Сопоставление со строками происходит не напрямую, а через объект `Matcher`, он хранит информацию о процессе сопоставления регулярного выражения и строки. Создать этот объект можно следующим образом:

```
Pattern timePattern = Pattern.compile("\\d\\d:\\d\\d");
Matcher m = timePattern.matcher("23:16");
```

Чтобы проверить, сопоставляется ли строка с регулярным выражением, надо вызвать метод `m.matches()`, вы получите логическое значение. В данном случае, это истина.

Объект после сопоставления содержит разную дополнительную информацию о том, как строка сопоставилась с выражением, но это мы обсудим позже. 

### Поиск подстрок, подходящих под регулярное выражение.

Допустим, мы имеем текст, котором встречаются подстроки, подходящие под регулярное выражение. Как их найти?

```
//Создаем matcher аналогично предыдущему
String text = "23:16 and 12:54 and 77:88, hello";
Pattern timePattern = Pattern.compile("\\d\\d:\\d\\d");
Matcher m = timePattern.matcher(text);

// Метод find() ищет очередное вхождение подстроки, подходящей под регулярное выражение
boolean found = m.find(); // вернет true, если нашел
System.out.println(found);
System.out.println(m.group()); // найденная подстрока
System.out.println(m.start()); // индекс начала
System.out.println(m.end()); // индекс конца

// чтобы найти следующий, делаем снова find

found = m.find(); // вернет true, если нашел еще один
System.out.println(found);
System.out.println(m.group()); // найденная подстрока
System.out.println(m.start()); // индекс начала
System.out.println(m.end()); // индекс конца

// обычно делают поиск в цикле
while (m.find()) {
    System.out.println(m.group());
    System.out.println(m.start()); // индекс начала
    System.out.println(m.end()); // индекс конца
}
```
